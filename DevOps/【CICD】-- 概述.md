# 导引

CI 代表持续集成，CD 代表持续交付或持续部署。个人认为，这是一种能比较好地将产品、开发、测试、运维等人员联系在一起，形成一条代码生产流水线，同时强调自动化的现代软件工程方法。

对于旧的开发模式来说，有几个比较大的缺陷：

- 对于开发和测试：开发完了才进行测试，开发收到的反馈和需要作出的修改都会集中在一个较短的时间段内，造成要在短时间内做出大量的修改。结果是开发觉得自己很苦逼，测试觉得开发很傻逼
- 对于开发和运维：开发完了，测试完了才第一次部署，运维收到的反馈和需要作出的修改都会集中在一个较短的时间段内，同时，产品经理在这个第一次的试用中也会发现较多业务逻辑相关的问题，短时间内运维忙得要死，开发要大量地返工，测试也要跟着改。结果是运维觉得自己很苦逼，开发觉得运维和产品很傻逼，测试觉得开发很傻逼

> 总的来说就是集成太慢，导致各个工种之间反馈太慢，最终导致项目质量延期或质量低下，而且容易产生鄙视链和相互甩锅。

# 方法

## 直观认识

跟其他的计算机知识一样，CI/CD 也是可以划分层次的，但是跟 TCP/IP、[磁盘 I/O](https://github.com/hsxhr-10/blog/blob/master/Linux/【磁盘%20IO】--%207%20层模型.md) 等分层结构不同的是，CI&CD 是一种类似御尾蛇的结构，如下图所示：

![](https://raw.githubusercontent.com/hsxhr-10/picture/master/CI%26CD1.png)

![](https://raw.githubusercontent.com/hsxhr-10/picture/master/CI%26CD4.png)

## 组成

### 涉及步骤

CI/CD 包含的步骤相对灵活，个人认为，以下几个是必须的：

- PLAN：需求落实。梳理需求的阶段，需求可以是业务需求、技术需求、fix bug 需求等，这一步着重的是人与人之间的交流探讨，目的是将思想中的需求转变成具体的看得到的东西，如流程图、文档等
- CODE：编码。将需求落实成代码的阶段，而现实情况是很多时候只有在编码时才能发现 PLAN 的漏洞或错误，在发现后应该及时反馈，所以 CODE 和 PLAN 是互相影响的
- BUILD：构建。将编写好的代码编译构建成可执行文件的阶段，解析型语言无需这步
- TEST：测试。运行代码对应测试的阶段，测试可以是单元测试、集成测试 (如接口测试)、UI 测试，注意人工测试验收不属于这一步
- DEPLOY STAGING：部署 STAGING 环境。将编译构建好的且通过了测试的可执行文件部署到 STAGING 环境的阶段，STAGING 是一个尽可能与线上环境一致的环境，包括架构一致、业务代码一致、数据一致
- ACCEPTANCE TEST：接纳测试。基本可以发布的阶段，当 TEST 没问题，DEPLOY STAGING 的验收没问题，就意味着 ACCEPTANCE TEST 是没问题的
- REVIEW：代码复查。细到代码级别检查的阶段，当 ACCEPTANCE TEST 通过了，意味着代码已经准备好部署到线上环境了，此时可以发起 code view，这些 view 着重于技术层面
- DEPLOY PRODUCTION：部署 PRODUCTION 环境。部署到线上环境的阶段
- MONITOR：监控。监控报警，日志收集阶段，对部署到线上的服务进行监控，一旦发现问题立刻通知相关人员进行处理

### 步骤的组合

#### PREPARE

PLAN <--> CODE 属于 PREPARE 阶段。需求如何扎实地交付给开发？需求文档要不要写，要写的话如何写？如何让需求文档和代码实现之间可以比较好地映射起来？这些都是这一层要思考的，这一层却很容易被弱化甚至忽略，轻 PLAN 重 CODE 往往会导致代码容易出现 bug，试想 PLAN 已经有漏洞了，实现的 CODE 肯定也会有问题的。详细的讨论可以参考 [这里](https://github.com/hsxhr-10/blog/blob/master/DevOps/【CI%26CD】--%20PLAN.md)。

#### CI PIPELINE

BUILD --> TEST --> DEPLOY STAGING 属于 CI PIPELINE 阶段。开发人员将某条分支的业务代码和对应的测试代码提交到代码仓库；触发 BUILD 来构建代码；构建成功后触发 TEST 来跑测试代码；测试成功后会将该条分支合并到 STAGING 环境的代码分支 (可能这条分支就叫 staging) 并部署好 STAGING 环境；值得注意的是这里的每一步都是自动化的。

只要 PIPELINE 中的任何一步失败了，这次的持续集成就算是失败了，失败的原因可能是因为测试不通过，可能是部署出了问题，无论是什么原因，开发、测试、运维都能迅速收到反馈并作出调整。同时，产品也可以通过这个统一的 STAGING 环境来进行测试，一旦发现跟既定的需求有出入，立刻提出。

通过 CI PIPELINE 将本来挤在短时间内的反馈和返工平摊到了茫茫多次的代码提交中，已经初步解决了大部分的问题。

#### CD PIPELINE

ACCEPTANCE TEST --> REVIEW --> DEPLOY PRODUCTION 属于 CD PIPELINE 阶段。当测试都通过了、测试覆盖率也不错、通过 STAGING 验收也没问题了之后，开发就可以发起合并请求，对应的人员 (小组长/技术负责人/同事等角色) 就可以进行 code review。当 review 也通过了，就可以部署到线上环境了。需要注意的是，DEPLOY PRODUCTION 这一步如果是需要人工操作的，则属于持续交付，如果这一步都是自动的 (比如根据几个指标都通过了就自动部署到线上)，那就属于持续部署。

个人认为，现实情况下不一定非得要追求持续部署，因为持续部署是非常吃测试的，无论是自动化测试还是人工测试，这会极大增加测试的难度和工作量，比如要求测试要包含丰富的单元测试、完善的接口测试、较多的 UI 测试，这对于很多中小公司来说不现实。

#### FEEDBACK

MONITOR --> PLAN 属于 FEEDBACK 阶段。当部署到线上环境后，必须要有一套监控机制，在出现异常时立刻通知相关人员，这些异常可能是系统层面的 (比如：CPU/MEMORY/DISK IO/NETWORK IO/PROCESS)，也可能是业务层面的 (比如：业务代码出错)。

在收到报警之后，就要依赖日志机制来帮助技术定位问题了，无论是业务日志或是系统相关日志。同时，最好开启类似 core dump 的功能，确保无论是内核崩溃还是用户进程崩溃后，都能留个黑匣子给自己。要知道当服务器假死时，任何线上排查技巧都是苍白的...

在收到报警并定位出问题之后，就可以新建 PLAN，然后继续新一轮的 CI&CD 了。

# 结果

CI&CD 能以其快速集成、快速反馈很好地解决旧开发模式的问题。跟 gitflow 一样，CI&CD 也不是死板的，而是可以根据每个团队的实际情况做出相应的变化，无论是实现工具的选择还是涉及步骤的选择，都没有绝对的标准，只有合适的标准。


