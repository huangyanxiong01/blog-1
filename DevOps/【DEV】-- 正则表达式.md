# 正则表达式
  - 是什么：用特定的符号表示一类字符串的集合
  - 怎么做
    - 第一步：举例 + 分解 + 每部分用正则描述 => 得出雏形
    - 第二步：扩展举例 + 检查每一部分的正则描述，若集合范围大了则增加正则符号，若集合范围小了则减少正则符号 => 得到完善的表达式
    - 重复第二步，直到正确为止
  - 正则表达式的组件
    - 普通字符
      - 数字
      - 字母
      - 标点符号
      - 其他符号
    - 非打印字符
      - \cx：匹配 Control-x 类型的键盘输入，比如 \cC 代表 Control-C 中断信号的输入
      - \s：匹配所有非打印字符，比如换行符、回车符、制表符等等
      - \S：\s 的取反
    - 特殊字符
      - *：匹配前面的表达式 0 次以上
      - ()：标记表达式，该表达式的匹配结果可被反向引用
      - |：匹配两个表达式的并集
      - \：转义符号
      - .：匹配除 \n 之外的任意一个字符
      - ?：匹配前面的表达式 0 次或 1 次
      - +：匹配前面的表达式 1 次以上
      - [-]：匹配一个范围，通常是 [0-9], [a-z], [A-Z]
      - [^]：匹配非后面的表达式
      - {m}：匹配前面的表达式 m 次
      - {m,}：匹配前面的表达式 m 次以上
      - {m,n}：匹配前面的表达式至少 m 次，最多 n 次
      - * 和 + 默认是贪婪匹配的，即尽可能地匹配到更多的字符
        ```
        待匹配串：<h1>Balabala</h1>
        贪婪的匹配串：<.*> 将会匹配到整个 <h1>Balabala</h1>
        非贪婪的匹配串：<.*?> 即在 * 或 + 后面加上 ?，那只会匹配到 <h1> 和 </h1>
        ```
    - 定位字符
      - ^：匹配开头的表达式
      - $：匹配结尾的表达式
      - \b：匹配字符的边界，即字符和空格的交界处
    - 反向引用
      - 利用 () 的缓存结果特性，\1 代表第一个表达式的缓存结果，一共可以缓存 99 个
      ```
      str = "i am go go kiki."
      par = "/([a-z]+)\s\1/ig"
      
      这个匹配串将会找出 相邻两个相同的单词
      ```
    - 一些有用的辅助标志
      - i：忽略字母的大小写
      - g：匹配尽可能多的结果出来
