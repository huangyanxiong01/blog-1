### <font color=#00b0f0>运行环境</font>

```
# uname -a
Linux ubuntu 3.16.0-30-generic #40~14.04.1-Ubuntu SMP Thu Jan 15 17:43:14 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux

# python2 --version
Python 2.7.9

# cat /etc/*-release
DISTRIB_DESCRIPTION="Ubuntu 14.04.2 LTS"

# 2G 内存
# CPU：2核
```

### <font color=#00b0f0>调优工具</font>

想要快速确定一个问题是 CPU 造成的，其实不是一件很容易的事情，因为 CPU 需要跟不同的子系统互相通信，所以很多时候表现出来的只是表象，背后真相可能是其他子系统造成的问题。比如当 CPU 的利用率很高时，有可能是真的在高速地处理者任务，也有可能是因为某个系统事件阻塞在那里；或者在增加了 CPU 数量之后，发现进程服务的 CPU 占用还是非常高。

除了 [【性能优化】-- top](https://github.com/hsxhr-10/blog/blob/master/Linux/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91--%20top.md) 中提到的 `top`，下面还会介绍一些其他非常好用的 CPU 调优工具

#### vmstat

```
root@ubuntu:/proc/28941# vmstat 1 
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 270968 121320 443424    0    0     1    82   61   33  0  0 99  0  0
 0  0      0 270984 121320 443424    0    0     0     0   83  188  1  1 99  0  0
 0  0      0 270984 121320 443424    0    0     0     0   56  113  0  0 100  0  0
 
 ...
```

- **r** 代表正在运行的进程数。由此可以大概了解 CPU 的繁忙程度
- **b** 代表阻塞的进程数。当这个值持续大于 0 时，可以推测 CPU 正在被某个进程阻塞，该进程的 CPU 占用率通常非常高，此时可以将排查方向转向该进程，看是否进程代码的编程模型出了问题，抑或是进程所依赖的其他系统出了问题
- **swpd** 代表磁盘 swap 的使用量。当这个值偏大时，频繁的磁盘 swap 会造成很大的 CPU 负担，此时可以将排查方向转向内存不足问题上
- **si/so** 代表 CPU 每秒从磁盘读/写入虚拟内存的大小。当这个两个值持续偏大时，排场方向同上
- **bi/bo** 代表块设备每秒读/写的块数量。当这个两个值持续偏大时，证明磁盘设备非常繁忙，可能会造成 `wa` 指标升高
- **in** 代表中断次数
- **cs** 代表上下文切换次数
- **us/sy** 代表用户进程和系统进程所占的 CPU 事件

1. 当 `r` 的值很大，`us+sy` 大于 80%，其他的指标正常时，可以初步推断为 CPU 资源不足，通过升级或者增加 CPU 资源解决。
2. 当 `swpd` 和 `si/so` 持续偏高时，可以初步推断为内存资源问题，通过排查是否存在[内存泄漏](https://github.com/hsxhr-10/blog/blob/master/Linux/%E3%80%90%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E3%80%91--%20%E9%AB%98%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8(1).md)或者增加内存解决。
3. 当 `bi/bo` 和 `wa` 持续偏高时，可以推断为磁盘资源问题，通过排查高磁盘 IO 进程或更换 SSD 解决。

> vmstat 关注的是**是否单纯因为 CPU 资源不足**；**是否因为其他子系统引发的 CPU 性能问题**

#### mpstat

```
root@ubuntu:/proc/28941# mpstat -P ALL 1
Linux 3.16.0-30-generic (ubuntu) 	05/26/2018 	_x86_64_	(2 CPU)

03:44:17 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
03:44:18 AM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:44:18 AM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:44:18 AM    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00

...
```

如果是多核的情况下，`mpstat` 命令能查看每个核心的情况。重点看到 `%irq` 字段，该字段代表了某一个核心被硬中断所占用的时间，当某一个核心的 `%irq` 值非常大，而其他核心的值却很小时，需要警惕是否中断分配出现了问题。

所谓硬中断指的是 CPU 和硬件的一种沟通方式，因为每个硬件 (磁盘、网卡) 都需要让 CPU 及时知道自己这边发生了什么事，这样 CPU 可能就会放下正在处理的任务进而去处理比较急的事件，像这种硬件主动干扰/通知 CPU 的行为就是硬中断。

默认情况下，系统提供 irqbalance 服务进行硬中断的分配，通常用户无需关心这个问题。但是在一些特殊的应用场景下，比如对于文件服务器、高流量 Web 服务器这样的应用来说，当发现多个网卡的请求都集中在同一个 CPU 时，通过把不同的网卡硬中断请求均衡绑定到不同的 CPU 上将会减轻某个 CPU 的负担，提高多个 CPU 整体处理中断的能力。具体绑定方法可以参考[这里](https://www.cnblogs.com/bamanzi/p/linux-irq-and-cpu-affinity.html)。












