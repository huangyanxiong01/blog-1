### 概述

本文以 c 环境为基础，讨论非法内存操作导致的 SIGSEGV/segmentation fault 程序异常结束和对应调试方法。因为很多语言或者组件都是 c 写的，所以如何解决这些内存问题也算是一个通用的技能了。

本文的思路为：通过 GDB 识别内存问题 --> 通过 Valgrind 定位内存问题。

*注意：下面默认 GDB 调试依赖了 core dump 文件，且被调试的程序都加了 -g 参数去编译构建。*

---

### 通过 GDB 识别内存问题

#### 1. 栈溢出

常见于超出了栈大小的递归调用。

通过 GDB 可以看到同一个函数被同一个地址重复调用。演示如下：

![](https://raw.githubusercontent.com/hsxhr-10/picture/master/栈溢出1.png)

#### 2. 栈被破坏

常见于多线程环境下的线程冲突、向已分配的内存空间之外写数据。

通过 GDB 可以看到 backtrace 的信息异常，栈被破坏的情况下，即使有部分栈信息可见，也不应该信任。演示如下：

![](https://raw.githubusercontent.com/hsxhr-10/picture/master/栈被破坏1.png)

![](https://raw.githubusercontent.com/hsxhr-10/picture/master/栈被破坏2.png)

---

### 通过 Valgrind 定位内存问题

Valgrind 很方便的一点是检测对象在编译时无需指定特定的选项，也不需要连接特定的函数库。

#### 1. 内存泄漏

演示代码如下：

```
shell> cat -n ./demo1.c
     1	#include <stdio.h>
     2	#include <stdlib.h>
     3	
     4	
     5	int main(void)
     6	{
     7		char *p = malloc(10);
     8		return 0;
     9	}
    10	
```

定位演示如下：

```
shell> valgrind --leak-check=yes ./demo1

==6719== Memcheck, a memory error detector
==6719== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==6719== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
==6719== Command: ./demo1
==6719== 
==6719== 
==6719== HEAP SUMMARY:
==6719==     in use at exit: 10 bytes in 1 blocks
==6719==   total heap usage: 1 allocs, 0 frees, 10 bytes allocated
==6719== 
==6719== 10 bytes in 1 blocks are definitely lost in loss record 1 of 1
==6719==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==6719==    by 0x40053E: main (demo1.c:7)
==6719== 
==6719== LEAK SUMMARY:
==6719==    definitely lost: 10 bytes in 1 blocks
==6719==    indirectly lost: 0 bytes in 0 blocks
==6719==      possibly lost: 0 bytes in 0 blocks
==6719==    still reachable: 0 bytes in 0 blocks
==6719==         suppressed: 0 bytes in 0 blocks
==6719== 
==6719== For counts of detected and suppressed errors, rerun with: -v
==6719== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```




