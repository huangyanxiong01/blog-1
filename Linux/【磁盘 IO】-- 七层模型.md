### 概述

时至今日，CPU 主频早已突破 3GHz，内存也步入 DDR4 时代，磁盘在容量上越来越大，但是机械磁盘读写性能性能的增长却远远跟不上 CPU 和内存，这是由于机械磁盘的物理结构的限制 (可以参考 [直观图](https://github.com/hsxhr-10/blog/blob/master/Linux/%E3%80%90%E7%A3%81%E7%9B%98%20IO%E3%80%91--%20%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87(%E8%A3%B8%E7%9B%98).md))，这也让机械磁盘 I/O 成了计算机性能提高的一个瓶颈。虽然有 SSD 磁盘的出现，读写 I/O 的性能比机械磁盘翻了 2 个数量级，但其较高的价格使得无法短时间内替代机械磁盘。

同时，对于系统管理员来说，相比 CPU 和内存的优化，磁盘 I/O 的性能优化选择多很多，但是，这些优化都是建立在一定的知识储备上的，如果没有这些储备就直接跳到优化这一步，就无法做到结合自己的实际情况，只能生搬硬套或者 “凭感觉” 去修改参数，这样往往会没效果甚至有反效果。因此，我觉得很有必要从块设备子系统的分层模型出发，逐层击破，弄明白各层的作用和联系，这样在优化时才有方向感。

---

### 七层模型

一个磁盘系统的分层模型如下：

![](https://raw.githubusercontent.com/hsxhr-10/picture/master/%E7%A3%81%E7%9B%98%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png)

![](https://raw.githubusercontent.com/hsxhr-10/picture/master/%E5%9D%97%E8%AE%BE%E5%A4%87%E5%88%86%E5%B1%82%E5%9B%BE2.jpg)

下面简单介绍每一层的意义：

- **VFS Layer**：虚拟文件系统层。主要作用有两个，1 是适配多不同的文件系统，让 Linux 可以兼容多种文件系统；2 是提供一套统一的操作接口，让用户进程无论是对于块设备、socket、字符设备、还是普通文件等的操作都能使用同样的接口，达到 “一切皆文件” 的效果。
- **Page Cache Layer**：页缓存层。主要作用又两个，1 是提供预读；2是提供回写。极大提高了磁盘的 I/O 性能
- **FS Layer**：文件系统层。主要作用有两个，1 是标记数据在物理设备的位置信息，让面向用户空间的路径能转换成面向物理设备的位置；2 是为 VFS 提供映射关系
- **Generic Block Layer**：通用块层。主要作用是提供了一个类似 VFS 层的块设备操作抽象层，下层对接各种不同属性的块设备，对上提供统一的 Block IO 请求标准 (上三层操作数据的单位是块/页，下三层操作数据的单位是扇区，从该层开始发出的就是以扇区为单位的面向物理设备的 I/O 请求)
- **I/O Scheduler Layer**：I/O 调度层。主要作用有两个，1 是合并相邻扇区的 I/O 请求；2 是对请求重新排序并调度
- **Block Device Drive Layer**：块设备驱动层。主要作用是负责和磁盘控制器打交道
- **Block Device Layer**：块设备层。主要作用是通过磁盘控制器读写物理设备

> 优化的性价比：Block Device Layer > Page Cache Layer > FS Layer > I/O Scheduler Layer > (VFS Layer, Generic Block Layer, Block Device Drive Layer)
