### <font color=#00b0f0>简介</font>

top 是一个以进程为核心的实时交互性能分析工具。当需要总体了解一个系统的状况时，top 非常适合做这件事。top 有 38 个统计字段，下面分析每个字段的意义、关键字段的性能指标、常用的交互操作命令。

---

### <font color=#00b0f0>运行环境</font>

```
# uname -a
Linux ubuntu 3.16.0-30-generic #40~14.04.1-Ubuntu SMP Thu Jan 15 17:43:14 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux

# python2 --version
Python 2.7.9

# cat /etc/*-release
DISTRIB_DESCRIPTION="Ubuntu 14.04.2 LTS"
```

---

### <font color=#00b0f0>字段的意义</font>

输入 `top`：

```
top - 14:06:20 up 14 days,  2:43,  1 user,  load average: 0.21, 0.17, 0.18
Tasks: 199 total,   2 running, 197 sleeping,   0 stopped,   0 zombie
%Cpu0  :  4.7 us,  2.7 sy,  0.0 ni, 92.3 id,  0.0 wa,  0.3 hi,  0.0 si,  0.0 st
%Cpu1  :  4.7 us,  2.7 sy,  0.0 ni, 92.3 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   8176960 total,  8033416 used,   143544 free,    18408 buffers
KiB Swap:        0 total,        0 used,        0 free.   271440 cached Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                
  991 gitlab-+  20   0  809516 122284   4832 S   3.3  1.5 109:55.09 prometheus                                                                             
 1680 root      20   0  134644  10428   3732 S   1.7  0.1 212:35.10 AliYunDun                                                                              
  970 git       20   0 1217372 677180   3240 S   1.0  8.3 198:48.10 bundle
```

**第一行：系统概况**

- 14:06:20：当前的系统时间
- up 14 days,  2:43：系统从开机成功到当前时间，所经过的时间
- 1 user：当前系统登陆的用户个数
- load average: 0.21, 0.17, 0.18：系统的平均负载，分别是 1 分钟、5 分钟、15分钟

**第二行：进程概况**

- 199 total：当前系统的进程总数（各种进程状态下的进程总数）
- 2 running：正在运行的进程
- 197 sleeping：睡眠的进程
- 0 stopped：停止的进程
- 0 zombie：僵尸进程

**第三行：cpu 信息**

- 4.7 us：用户进程所占 cpu 时间百分比
- 2.7 sy：内核进程所占 cpu 时间百分比
- 0.0 ni：renice 过的进程所占 cpu 时间百分比
- 92.3 id：cpu 空闲时间百分比
- 0.0 wa：cpu 等待 io (磁盘 io 或网络 io) 所占 cpu 时间百分比
- 0.3 hi：硬中断 所占 cpu 时间百分比
- 0.0 si：软中断 所占 cpu 时间百分比
- 0.0 st：当多个虚拟机共用一个物理机时，你所使用的虚拟机不能使用 cpu 的时间百分比

**第四行：出现在多核 cpu，字段同上**

**第五行：物理内存信息（单位 kbyte）**

- 8176960 total：物理内存总大小
- 8033416 used：已使用的物理内存大小
- 143544 free：未使用的物理内存大小
- 18408 buffers：用于缓存的物理内存大小

**第六行：交换区信息和一个物理内存信息**

- 0 total：交换去总大小（没有设置交互去则为 0）
- 0 used：已使用的交换去大小
- 0 free：剩余交换区大小
- 271440 cached Mem：用于缓存的物理内存大小

> 关于物理内存的 buffer 和 cached：首先，buffer 代表的是处于缓冲区等待被写入磁盘的数据所占的物理内存大小，cached 代表的是从磁盘被读出来放到缓存区的数据所占的内存大小；其次，两者都属于 used，只是用途不同的 used 而已

**第七行：进程详细信息**

- PID：进程 id
- USER：进程属主
- PR：进程优先级
- NI：进程 nice 值
- VIRT：进程所占的虚拟内存大小
- RES：进程所占物理内存大小
- SHR：进程所占的共享内存大小
- S：进程状态（S->睡眠、R->运行、Z->僵尸、N->该进程优先级为负数）
- %CPU：进程所占 cpu 百分比
- %MEM：进程所占内存百分比
- TIME+：从进程启动到当前时间，所占的 cpu 时间总和
- COMMAND：启动进程的命令

> 关于物理内存、虚拟内存、共享内存：
>
> 1、这三个概念是什么意思？
>
> 物理内存：插在服务器上面实实在在摸得着的硬件内存
>
> 虚拟内存：内核为了管理进程内存所提出的一个抽象层。对于 cpu 来说，它所操作的内存地址其实是虚拟内存地址，然后内核通过页面映射机制 (page size) 将虚拟内存地址映射到物理内存地址
>
> 共享内存：进程 A 和 B 都会用到同一个依赖库 L，L 所占用的内存就分别是 A 和 B 的共享内存
>
> 2、为什么需要虚拟内存？
>
> 最主要的原因是利用虚拟内存中按需映射的原则，来突破物理内存的限制。比如，服务器的物理内存是 1G，但是有一个服务进程需要 2G 的内存，此时，如果给服务进程分配的是物理内存，显然是无法启动该服务的。有了虚拟内存机制后，内核可以给服务进程分配一个比较大的虚拟内存用于服务的启动，然后在进程运行的过程中，按实际需要通过页面映射去分配物理内存。从而达到小内存机器能运行更多的大型程序，使得硬件资源最大化被使用。
>
> 3、简单图解虚拟内存
>
> ![IMG](https://user-gold-cdn.xitu.io/2018/5/12/16353b403d061842?w=1440&h=1080&f=jpeg&s=154477)
>
> 假设服务器的物理内存为 1G，进程 A 所需的内存为 1G，进程 B 所需的内存为 1 G，由于虚拟内存机制的存在，服务器可以同时运行这两个进程。
>
> 其中，第一行代表虚拟内存。对于进程 A， A1~A4 就是在运行过程中，按需被映射的虚拟内存，没被标记的空白部分就是暂时不需要映射的部分。对于进程 B 中的 B1~B3 也同理。
>
> 第二行代表 page table。这两个 page table 就是内核分别为两个进程分配的，相当于一个转换器，把虚拟内存地址映射到物理内存地址。
>
> 第三行代表物理内存。 A1~A4、B1~B3 就是被映射后的结果。其中 A4 和 B3 是两个进程都用到的依赖库，因此会被映射到同一段物理内存，这段物理内存也就是上面所说的共享内存。

> 关于 PR 和 NI 的一个实验：
>
> 写了两个脚本，内容基本相同，为了方便对 TIME+ 指标的观察，两个脚本都是死循环地输出一个字符串，如下：
>
> ```
> # demo2.py
> import time
> while 1:
>     print 'demo2'
>
> # demo3.py
> import time
> while 1:
>     print 'demo3'
> ```
>
> 其中，demo2.py 运行在 pts/3 上，demo3.py 运行在 pts/4 上。通过 `renice` 将 demo2.py 和 pts/3 的 nice 值设置成 -20，将 demo3.py 和 pts/4 的 nice 值设置成 20。运行十分钟后的结果如下：
>
>```
>top - 21:54:59 up 4 days, 23:41,  4 users,  load average: 3.89, >3.55, 2.95
>Tasks: 178 total,   4 running, 174 sleeping,   0 stopped,   0 >zombie
>%Cpu(s): 11.9 us, 72.2 sy, 11.2 ni,  0.0 id,  0.0 wa,  0.0 hi,  >4.8 si,  0.0 st
>KiB Mem:   1014068 total,   352744 used,   661324 free,    21060 >buffers
>KiB Swap:        0 total,        0 used,        0 free.   168828 >cached Mem
>
>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                
>23221 root       0 -20  120376   8000   5816 R  35.1  0.8   4:57.22 sshd: root@pts/3                                                                       
>23255 root      39  19  120248   7872   5872 S  34.5  0.8   4:38.13 sshd: root@pts/4                                                                       
>23547 root       0 -20   24260   6724   4176 S  35.5  0.7   3:49.88 python demo2.py                                                                        
>23551 root      39  19   24260   6904   4360 R  35.5  0.7   3:43.76 python demo3.py                                                                        
>10591 root      20   0  434048  40640  26776 S   0.7  4.0   3:16.82 /usr/bin/dockerd --raw-logs                                                            
>23570 root      20   0       0      0      0 S  28.8  0.0   2:18.92 [kworker/0:2]                                                                          
>23619 root      20   0       0      0      0 S  28.8  0.0   1:03.04 [kworker/1:1]                                                                          
>77 root      20   0       0      0      0 S   0.3  0.0   0:08.49 [ksoftirqd/1]                                                                          
>23467 root      20   0   24980   3076   2540 R   0.3  0.3   0:02.31 top
>```
>
> 可以看到 TIME+ 这一项，demo2.py 对 cpu 的占用时间已经比 demo3.py 要多 6s 了，要知道 cpu 时间的 1s 是可以发生很多事情的。当然并不是一开始就多 6 秒，而是慢慢累积起来的，可以设想随着运行时间的增加，demo2.py 和 demo3.py 之间的 TIME+ 差距将会越来越大
>
> 实验结果：1. 修改 nice 值对于 cpu 调度进程确实是有影响的；2. 修改 nice 之后并不是立竿见影的，而是随着进程运行时间的增加，TIME+ 的差距才会越来越明显

---

### <font color=#00b0f0>字段的性能指标</font>

接下来对部分字段的性能指标做分析：

*(注：下面所说的推荐升价硬件是在系统没有异常的进程且性能指标不佳的情况下)*

- **14:06:20**：通过该字段可以快速得知服务器时间是否正确，服务器时间往往会影响到业务代码，在实践过程中就有遇到过服务器时间少了 8 小时，从而导致业务代码中关于时间的地方也漏了 8 小时的情况
- **up 14 days,  2:43**：当这个时间很短，而在其间管理员并没有执行重启、关机等操作时需要提高警惕了，因为很可能是非管理人员对服务器进行了一些非法操作
- **1 user**：当该数字超出正常用户数时，需要提高警惕
- **load average**：一般情况下，该数值要 <= cpu 核心数 * 每个核的线程数。如果超过设置远远超过该阙值，有可能是运行的进程数太多，或者新增了一个 cpu 密集型的服务，此时可以考虑升级 cpu 或调整技术架构；也有可能是存在非法的进程在运行，此时需要找出该进程，采取相应的措施
- **199 total**：当该数值比较大，且系统平均负载也很大时，可以考虑升级 cpu
- **0 zombie**：由于僵尸进程只是现象，并不是问题的根本，问题的根本是僵尸进程的父进程。正是由于父进程没有合理地 wait() 子进程才导致了僵尸进程。因此，当该数值非 0 时，可以先通过 `ps -A -o stat,ppid,pid,cmd | grep -e '^[Zz]'` 找出僵尸进程的 PID；然后通过 `ps -f PID` 找出僵尸进程的 PPID；分析原因；执行 `kill -9 PPID`
- **4.7 us 和 2.7 sy**：一般情况下，us + sy >= 80% 则说明 cpu 资源有可能不足
- **92.3 id**：该数值很大或者很小都可能是正常的，具体要看当前服务器上所部署的服务情况
- **0.0 wa**：一般情况下，如果服务器装的是机械硬盘，则该数值 <= 30% 是正常的，如果装的是 SSD，则应该 <= 8%。在阿里云平台的实践中，发现该数值 >= 40% 时，登陆服务器的命令行打命令就会感觉到明显的卡顿，更高时甚至无法 ssh 登陆服务器。并且很多时候该数值过高是因为内存资源不足，导致系统频繁发生 swap 操作，从而导致磁盘负载大，最终的结果是 wa 的数值高且服务器陷入假死状态。这种情况是无法通过命令行去实时排查问题的，因为服务器已经卡住了，此时就需要一些事后分析手段了，具体方法打算在另外的文章中再讨论
- **0.3 hi 和 0.0 si**：可以参考下网上两篇文章：[VPS with very high Load - "si" software interrupts ??](http://www.webhostingtalk.com/showthread.php?t=992765) 和 [网卡软中断过高问题优化总结](http://www.simlinux.com/2017/02/28/net-softirq.html)
- **0.0 st**：当所使用的服务器是并非物理服务器且该数值过高时，有可能是分配给你的虚拟机的 cpu 资源偷偷被减少了，可以向平台运营商提交工单

---

### <font color=#00b0f0>交互操作</font>

C：按照进程对 cpu 的使用率从大到小排序

M：按照进程对内存的使用率从大到小排序

T：按照进程对 cpu 的占用时长从大到小排序

H：按照线程对 cpu 的中用时长从大到小排序

c：显示命令完全模式，可以方便地区分内核进程和用户进程 (内核进程是被 `[]` 包着的)

k：执行 `kill` 命令

r：执行 `renice` 命令

i：只显示活动的进程
