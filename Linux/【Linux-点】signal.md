系统底层的事件都是由内核去处理的，正常来说对用户空间是透明的。但是用户空间的进程往往也需要知道某种类型的事件是否发生了，这个时候就需要有一种通信机制。信号就是一种通信接口，让内核进程和用户进程、用户进程和用户进程之间可以彼此沟通

---

### <font color=#00b0f0>运行环境</font>

```
# uname -a
Linux ubuntu 3.16.0-30-generic #40~14.04.1-Ubuntu SMP Thu Jan 15 17:43:14 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux

# python2 --version
Python 2.7.9

# cat /etc/*-release
DISTRIB_DESCRIPTION="Ubuntu 14.04.2 LTS"

# 2G 内存
# CPU：2核
```

---

### <font color=#00b0f0>了解信号</font>

#### 信号的产生

- 被动：当某种类型的事件发生了，被内核或者相应的驱动程序检测到，内核或者驱动程序就会向用户进程发送信号
- 主动：用户进程主动调用信号发送函数 (如 kill) 向另一个用户进程发送信号

#### 常见信号

| 编号     | 名称     | 代表事件  | 默认处理  | 产生   |
|----------|----------|----------|----------|----------|
| 1 | SIGHUP | 终端挂断 | 终止 | 终端 |
| 2 | SIGINT | 键盘中断 | 终止 | 键盘驱动 |
| 3 | SIGQUIT | 键盘退出 | 终止 | 键盘驱动 |
| 4 | SIGILL | 代码非法指令 | 终止 | 内核 |
| 9 | SIGKILL | 杀死进程 | 终止 | 内核 |
| 10 | SIGUSR1 | 用户定义的信号 1 | 终止 | 内核 |
| 12 | SIGUSR2 | 用户定义的信号 2 | 终止 | 内核 |
| 14 | SIGALRM | alarm 函数的定时器信号 | 终止 | 内核 |
| 15 | SIGTERM | /bin/kill 命令的默认信号 | 终止 | 内核 |
| 17 | SIGCHLD | 一个子进程的终结 | 忽略 | 内核 |
| 18 | SIGCONT | 继续被停止的进程 | 忽略 | 内核 |
| 19 | SIGSTOP | 停止进程直到接受到 SIGCONT 信号 | 停止/挂起 | 内核 |

> 进程对于信号的处理方式有 4 种：捕获、忽略、阻塞、默认；其中默认处理方式有 3 种：终止、忽略、挂起

- **SIGHUP**：在实际的工程实现中，这个信号更多时候是被守护进程重制用的，一般某个守护进程接收到该信号后，会先稳妥地关闭掉自己，然后以新的配置文件来重新启动。比如 nginx 中的 HUP 就是这种意思
- **SIGQUIT**：和 `SIGHUP` 类似，现实的工程实现中，这个信号往往会被用来稳妥地关闭自己。比如 nginx 中的 QUIT 信号
- **SIGINT**：当我们键入 `<Control-C>` 时，键盘驱动就会发出该信号
- **SIGTERM**：`kill` 命令的默认参数，和 `SIGKILL` 相比更像是请求进程退出
- **SIGKILL**：无法被**捕获**、**忽略**、**阻塞** 的信号，强制性进程退出，除僵尸进程外的其他进程都可以被这个信号杀掉
- **SIGSTOP**：无法被**捕获**、**忽略**、**阻塞** 的信号，被挂起的进程会一直等着 `SIGCONT` 信号的到来
- **SIGCONT**：无法被**阻塞**的信号

#### 验证 SIGKILL 和 SIGSTOP

```
```
