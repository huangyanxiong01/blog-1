### <font color=#00b0f0>运行环境</font>

```
# uname -a
Linux ubuntu 3.16.0-30-generic #40~14.04.1-Ubuntu SMP Thu Jan 15 17:43:14 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux

# cat /etc/*-release
DISTRIB_DESCRIPTION="Ubuntu 14.04.2 LTS"

# 内存：2G
# CPU：2核
# GDB: 7.7.1
```

---

### 概述

本文讨论的是发生在用户空间的死锁。列举两种情况：1 个线程造成的死锁；2 个线程造成的死锁。通过这两种情况说明如何使用 GDB 调试死锁问题。

---

### 调试步骤

#### 0. 预备操作

演示代码 `deadlock.c` 如下：

```
1	#include <stdio.h>
2	#include <pthread.h>
3	#include <stdlib.h>
4	
5	
6	pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
7	int cnt = 0;
8	
9	
10	void cnt_reset(void)
11	{
12		pthread_mutex_lock(&mutex); // 死锁位置
13		cnt = 0;
14		pthread_mutex_unlock(&mutex);
15	}
16	
17	
18	void* thr(void *arg)
19	{
20		while(1)
21		{
22			pthread_mutex_lock(&mutex); // 第一次获取锁
23			if (cnt > 2)
24				cnt_reset();
25			else
26				cnt++;
27			pthread_mutex_unlock(&mutex);
28	
29			printf("%d\n", cnt);
30			sleep(1);
31		}
32	}
33	
34	
35	int main(void)
36	{
37		pthread_t tid;
38		
39		pthread_create(&tid, NULL, thr, NULL);
40		pthread_join(tid, NULL);
41	
42		return 0;
43	}
44	
```

#### 1. 识别死锁

运行代码后，使用 `ps` 命令查看进程的状态，演示如下：

```
shell> ps aux | grep deadlock | grep -v grep
root      2554  0.0  0.0  14708   716 pts/0    Sl+  12:39   0:00 ./deadlock
```

留意进程的状态是 `Sl+`，证明进程在等待锁，且无论过了多久，进程都保持这个状态，可以确定进程 2554 发生死锁了。

#### 2. GDB 定位死锁原因

启动 GDB：

```
shell> gdb
...
```

attach 到 2554：

```
(gdb) attach 2554
Attaching to process 2554
Reading symbols from /root/deadlock...done.
Reading symbols from /lib/x86_64-linux-gnu/libpthread.so.0...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/libpthread-2.19.so...done.
done.
[New LWP 2555]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Loaded symbols for /lib/x86_64-linux-gnu/libpthread.so.0
Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.19.so...done.
done.
Loaded symbols for /lib/x86_64-linux-gnu/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/ld-2.19.so...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
0x00007f1fd386865b in pthread_join (threadid=139774665512704, thread_return=0x0) at pthread_join.c:92
92	pthread_join.c: ?????????.
```

查看线程情况，有两个线程，当前在线程 1 上：

```
(gdb) info threads 
  Id   Target Id         Frame 
  2    Thread 0x7f1fd3495700 (LWP 2555) "deadlock" __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
* 1    Thread 0x7f1fd3c95740 (LWP 2554) "deadlock" 0x00007f1fd386865b in pthread_join (threadid=139774665512704, thread_return=0x0) at pthread_join.c:92
```

##### 2.1. 检查第一个线程

查看线程 1 的栈：

```
(gdb) bt
#0  0x00007f1fd386865b in pthread_join (threadid=139774665512704, thread_return=0x0) at pthread_join.c:92
#1  0x000000000040084e in main () at deadlock.c:40
```

查看 #1 栈和 40 行附近的源码：

```
(gdb) frame 1
#1  0x000000000040084e in main () at deadlock.c:40
40		pthread_join(tid, NULL);
(gdb) list 40
35	int main(void)
36	{
37		pthread_t tid;
38		
39		pthread_create(&tid, NULL, thr, NULL);
40		pthread_join(tid, NULL);
41	
42		return 0;
43	}
44	
```

查看寄存器信息，并输出锁信息：

```
(gdb) info reg
rax            0xfffffffffffffe00	-512
rbx            0x0	0
rcx            0xffffffffffffffff	-1
rdx            0x9fb	2555
rsi            0x0	0
rdi            0x7f1fd34959d0	139774665513424
rbp            0x7fffb8dc4f70	0x7fffb8dc4f70
rsp            0x7fffb8dc4f60	0x7fffb8dc4f60
r8             0x0	0
r9             0x7f1fd3495700	139774665512704
r10            0x0	0
r11            0x246	582
r12            0x4006a0	4196000
r13            0x7fffb8dc5050	140736294834256
r14            0x0	0
r15            0x0	0
rip            0x40084e	0x40084e <main+52>
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) p *(pthread_mutex_t*)0x0
Cannot access memory at address 0x0
```

**在 x86_64 平台上，寄存器 `r8` 的第一个参数代表的是该线程拥有的锁的地址。**可以看到该线程并没有占有锁，到这里为止，可以肯定线程 2554 并没有发生死锁。












