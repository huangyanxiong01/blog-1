# 数据结构

一些约定：

- 下面讨论的都是一般情况下的标准数据结构描述，比如链表一般情况下不支持索引操作
- 时间复杂度里面的 “增” 是指在末尾或开头增加，不是指特定位置，“删” 也同理，而 “查” 则是指查找不确定的位置

一些通用技巧：

- 数据结构中存在大量的正反推理，比如从树的遍历结果重新建立树、从序列判断是站还是队列等等
- 时 / 空交换
- 用自己的话来描述算法的结构，对代码实现很有帮助

## 结构

- 物理结构
  - 连续固定内存分配
  - 链式动态内存分配

- 逻辑结构：逻辑结构不同的数据结构，其物理结构可以是一样。像栈和队列，其实物理结构是一样的，可以同为连续固定或链式动态。只是指针操作不相同造成的逻辑结构不同，比如栈的头指针总是指着最后的 item，从而形成先进后出的逻辑结构，队列的头指针总是指向第一个 item，所以形成先进先出的逻辑结构

- 线性结构
- 非线性结构

## 代码实现

- 线性结构：数组、链表、栈/队列等，代码实现相对容易，普遍以指针在线性结构上如何摆放、如何移动为主
- 非线性结构：二叉树、二叉搜索树、散列表、图等，代码实现相对困难，夹杂着额外需要处理的事项，如二叉搜索树的删除操作、散列表的冲突解决

##  Array

- 特点
  - 索引查的时间效率高，可用来作为 hashing 的物理结构
  - 空间效率低，一般固定大小，创建前需要知道大小；增删若超过固定大小，默认出错，可进行扩容，但动态扩容比较影响性能
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)
  - 索引查：O(1)

## Linked List

*特指基本的后向链表。其他的像双向链表、循环链表、双向循环链表、指针随意指的复杂链表等不在这讨论。*

- 特点
  - 空间效率高，天生动态扩容，创建前无需知道大小 (其实这个是链式物理结构的特点，也不是只有链表才是这样，像链式的栈也不需要提前知道大小)
  - 时间效率偏低，因为不支持索引查
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 对于一些复杂的链表，可以分解成 “基本链表 + 其他”

## Stack/Queue

栈和队列之间看似相反，但是也存在着物理结构可以相同的特质。所以会有一些像 “用两个队列实现标栈功能” 或 “用两个栈实现队列功能” 的问题。

### Stack

- 特点
  - 先进后出，适用于反转、颠倒输入输出等场景
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 栈搭配其他数据结构来解决问题是比较常用的技巧

### Queue

*特指基本的先进先出队列。其他的像循环队列、双端队列等不在这讨论。*

- 特点
  - 先进先出
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 对于一些复杂的链表，可以分解成 “基本的 + 其他”；队列搭配其他的数据结构是比较常用的技巧

## Tree

- 伴随着递归
- 指针操作复杂
- 树的遍历分两类：纵向遍历和横向遍历 (类似图的深度优先和广度优先)
- 树的路径问题优先使用纵向遍历，特别是前序遍历
- 树的层级问题优先使用层序遍历
- “画出最小树 + 标明指针 + 树的递归遍历模型填空” 是使用树的递归模型来解决问题的一般性方法

### Binary Tree

- 特点
  - 最常见
  - 每个节点的子节点数量 <= 2
  - 关键结构
    - 父亲节点
    - 左子树
    - 右子树
  - 遍历
    - 前序遍历：root 总在遍历结果序列的第一个
    - 中序遍历：root 的左边总是左子树，右边是右子树
    - 后序遍历：root 总在遍历结果序列的最后一个
- 时间复杂度 (要看数据的分布情况，可能会退化成链表)
  - 增：[O(1), O(log(n))]
  - 删：[O(1), O(log(n))]
  - 查：[O(log(n)), O(n)]
- 代码实现
  - 7 种遍历

### Binary Search Tree

- 特点
  - 左儿子的某个值必须 <= root
  - 右儿子的某个值必须 >= root
- 时间复杂度
  - 增：O(log(n))
  - 删：O(log(n))
  - 查：O(log(n))
- 代码实现
  - 增
  - 查

> 个人认为树相关问题的思路优先级：层序遍历 > 比较单纯的纵向遍历 / 比较单纯的纵向遍历 + 其他数据结构 > 递归模型

## Hashing

效率/高效/高性能的代名词，空间换时间的杰出代表，你值得拥有。

- 特点
  - Hashing 函数
    - 整数：求余
    - 浮点数：浮点数 => 字符串 => 整数 => 求余
    - 字符串：字符串 => 整数 => 求余
    - 混合型：各混合部分 => 整数 => 求余
- 时间复杂度
  - 增：O(1) / 拉链法冲突时 => O(n)
  - 删：O(1)
  - 查：O(1)
- 代码实现
  - Hashing 函数设计
  - 拉链法
  - 拉链法冲突解决
  - 线性探测法
  - 线性探测法冲突解决

## Graph

# 算法

## Search

### Sequence Search

### Binary Search

### Hashing Search

- 在第一次遍历的时候顺便做 hashing 是个实用的技巧

### Binary Search Tree

### Quick Search

- 代码实现描述
  - 核心思想：挖坑 + 前、后往中间移动直到相等
  - 快速排序 = 技术选择 (可引入随机选择) + 大循环条件 while (i != j) + j 从后往前移动，找比基准数小的数，找到就交换 arr[i] 和 arr[j]，i 后移一位 + i 从前往后移动，找比基准数大的数，找到就交换 arr[i] 和 arr[j]，j 前移一位
- 代码实现
- 时间复杂度
  - 平均
  - 最差
- 空间复杂度

## Sorting

### Quick Sort

### Merge Sort

### Count Sort

## String

## Graph


















