# 数据结构

*下面讨论的都是一般情况下的标准数据结构描述，比如链表一般情况下不支持索引操作。同时时间复杂度里面的 “增” 是指在末尾或开头增加，不是指特定位置，“删” 也同理，而 “查” 则是指查找不确定的位置。*

数据结构中存在大量的正反推理，比如从树的遍历结果重新建立树、从序列判断是站还是队列等等。

## 结构

- 物理结构
  - 连续固定内存
  - 链式动态内存

- 逻辑结构：逻辑结构不同的数据结构，其物理结构可以是一样。像栈和队列，其实物理结构是一样的，可以同为连续固定或链式动态。只是指针操作不相同造成的逻辑结构不同，比如栈的头指针总是指着最后的 item，从而形成先进后出的逻辑结构，队列的头指针总是指向第一个 item，所以形成先进先出的逻辑结构

##  Array

- 特点
  - 索引查的时间效率高，可用来作为 hashing 的物理结构
  - 空间效率低，一般固定大小，创建前需要知道大小；增删若超过固定大小，默认出错，可进行扩容，但动态扩容比较影响性能
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)
  - 索引查：O(1)

## Linked List

*特指基本的后向链表。其他的像双向链表、循环链表、双向循环链表、指针随意指的复杂链表等不在这讨论。*

- 特点
  - 空间效率高，天生动态扩容，创建前无需知道大小 (其实这个是链式物理结构的特点，也不是只有链表才是这样，像链式的栈也不需要提前知道大小)
  - 时间效率偏低，因为不支持索引查
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 对于一些复杂的链表，可以分解成 “基本链表 + 其他”

## Stack/Queue

栈和队列之间看似相反，但是也存在着物理结构可以相同的特质。所以会有一些像 “用两个队列实现标栈功能” 或 “用两个栈实现队列功能” 的问题。

### Stack

- 特点
  - 先进后出，适用于反转、颠倒输入输出等场景
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 栈搭配其他数据结构来解决问题是比较常用的技巧

### Queue

*特指基本的先进先出队列。其他的像循环队列、双端队列等不在这讨论。*

- 特点
  - 先进先出
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 对于一些复杂的链表，可以分解成 “基本的 + 其他”；队列搭配其他的数据结构是比较常用的技巧

## Tree

- 树的遍历分两类：纵向遍历和横向遍历 (就是图的深度优先和广度优先)
- 遍历是树的绝对核心，树的 7 种遍历操作必须要随时都能写得出来 (递归/非递归的前序遍历、递归/非递归的中序遍历、递归/非递归的后序遍历、层序遍历)
- 遍历的特点
  - 前序遍历：
- 树的路径问题优先使用纵向遍历，特别是前序遍历
- 树的层级问题优先使用层序遍历
- “画出最小树 + 标明指针 + 树的递归遍历模型填空” 是使用树的递归解决问题的一般性方法

### Binary Tree

### Binary Search Tree

## Hashing

## Graph

# 算法








