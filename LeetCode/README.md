# 数据结构

*下面讨论的都是一般情况下的标准数据结构描述，比如链表一般情况下不支持索引操作。同时时间复杂度里面的 “增” 是指在末尾或开头增加，不是指特定位置，“删” 也同理，而 “查” 则是指查找不确定的位置*

## 结构

- 物理结构
  - 连续固定内存
  - 链式动态内存

- 逻辑结构：逻辑结构不同的数据结构，其物理结构可以是一样。像栈和队列，其实物理结构是一样的，可以同为连续固定或链式动态。只是指针操作不相同造成的逻辑结构不同，比如栈的头指针总是指着最后的 item，从而形成先进后出的逻辑结构，队列的头指针总是指向第一个 item，所以形成先进先出的逻辑结构

##  Array

- 特点
  - 索引查的时间效率高，可用来作为 hashing 的物理结构
  - 空间效率低，一般固定大小，创建前需要知道大小；增删若超过固定大小，默认出错，可进行扩容，但动态扩容比较影响性能
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)
  - 索引查：O(1)

## Linked List

*特指基本的后向链表。其他的像双向链表、循环链表、双向循环链表、指针随意指的复杂链表等不在这讨论。*

- 特点
  - 空间效率高，天生动态扩容，创建前无需知道大小 (其实这个是链式物理结构的特点，也不是只有链表才是这样，像链式的栈也不需要提前知道大小)
  - 时间效率偏低，因为不支持索引查
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 对于一些复杂的链表，可以分解成 “基本链表 + 其他”

## Stack

- 特点
  - 先进后出，适用于反转、颠倒输入输出等场景
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 栈搭配其他数据结构来解决问题是比较常用的技巧

## Queue

*特指基本的先进先出队列。其他的像循环队列、双端队列等不在这讨论。*

- 特点
  - 先进先出
- 时间复杂度
  - 增：O(1)
  - 删：O(1)
  - 查：O(n)

> 对于一些复杂的链表，可以分解成 “基本的 + 其他”；队列搭配其他的数据结构是比较常用的技巧

## Tree

### Binary Tree

### Binary Search Tree

## Hashing

## Graph

## 一些思路

- 明确每种数据结构的特点、使用场景
- 简单难度的问题一般只用一种数据结构就可以解决；中等难度的问题往往需要 2 种以上的数据结构结合使用

# 算法
